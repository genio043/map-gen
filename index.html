<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Genera mapas procedurales para mazmorras, paisajes y ciudades. Perfecto para RPGs, roguelikes y juegos de estrategia. ¡Gratis, online y en español 2025!">
    <meta name="keywords" content="generador de mapas para juegos, crear mazmorras procedurales, mapas aleatorios para RPGs, generador de niveles para juegos, herramienta mapas procedurales, map generator gaming, procedural dungeon generator, game dev map tool, generador de mapas gratis, map generator online 2025">
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "¿Qué es un generador de mapas procedurales?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Un generador de mapas procedurales crea mapas aleatorios para juegos, como mazmorras, paisajes o ciudades, usando algoritmos para generar diseños únicos."
          }
        },
        {
          "@type": "Question",
          "name": "¿Cómo usar el Generador de Mapas para Juegos?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Selecciona el tipo de mapa, tamaño y densidad, luego haz clic en 'Generar Mapa' para ver el resultado. Puedes exportar el mapa como PNG para usarlo en tu juego."
          }
        }
      ]
    }
    </script>
    <title>Generador de Mapas para Juegos - Genio043 Tools</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1080px;
            margin: 20px auto;
            padding: 20px;
            background: #1e1e1e;
            color: #ddd;
            text-align: center;
        }
        h1 { font-size: 28px; color: #00ccff; }
        h2 { font-size: 20px; color: #00ff99; margin: 10px 0; }
        .section {
            margin: 20px 0;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
        }
        .input-group {
            display: inline-block;
            margin: 10px;
            vertical-align: top;
        }
        label { display: block; margin-bottom: 5px; color: #bbb; }
        input, select {
            padding: 8px;
            width: 80px;
            font-size: 14px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #333;
            color: #fff;
        }
        button {
            padding: 10px 20px;
            background: #00ccff;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0099cc; }
        #resetBtn { background: #ff4444; }
        #resetBtn:hover { background: #cc3333; }
        .donate a { color: #00ccff; font-weight: bold; text-decoration: none; }
        @media (max-width: 500px) {
            input, select { width: 60px; }
            .input-group { margin: 5px; }
            h1 { font-size: 22px; }
        }
        canvas {
            width: 70vw; /* 80% del ancho de la ventana */
            height: 70vh; /* 80% del alto de la ventana */
            min-width: 300px; /* No más chico que 300px en pantallas pequeñas */
            min-height: 300px; /* Alto mínimo para legibilidad */
            max-width: 1080px; /* Límite superior para pantallas enormes */
            max-height: 800px; /* Límite superior para no exagerar */
            margin: 20px auto; /* Centrado con espacio */
            display: block; /* Evita problemas de inline */
            border: 1px solid #444;
            border-radius: 4px;
        }
        a:visited {
            color: #ff9900;
        }
        footer {
            background: #2a2a2a;
            padding: 15px 0px;
            text-align: center;
            position: relative;
            bottom: 0;
            width: 100%;
            border-top: 1px solid #00ccff;
        }
        footer p {
            margin: 0;
            font-size: 16px;
            color: #bbb;
        }
        footer a {
            color: #00ff99;
            text-decoration: none;
            font-weight: bold;
            transition: all 0.3s;
        }
        footer a:hover {
            color: #1e1e1e;
            background: #00ff99;
            padding: 5px 10px;
            border-radius: 4px;
            box-shadow: 0 0 10px #00ff99;
        }
    </style>
</head>
<body>
    <h1>Generador de Mapas para Juegos</h1>
    <p>Crea mapas procedurales para mazmorras, paisajes o ciudades. Perfecto para RPGs, roguelikes y juegos de estrategia.</p>
    <div class="section">
        <h2>Configuración</h2>
        <div class="input-group">
            <label>Tipo de mapa:</label>
            <select id="map-type">
                <option value="dungeon">Mazmorra</option>
                <option value="landscape">Paisaje</option>
                <option value="city">Ciudad</option>
            </select>
        </div>
        <div class="input-group">
            <label>Tamaño del mapa:</label>
            <select id="map-size">
                <option value="small">Pequeño (20x20)</option>
                <option value="medium">Mediano (40x40)</option>
                <option value="large">Grande (60x60)</option>
            </select>
        </div>
        <div class="input-group">
            <label>Densidad:</label>
            <select id="density">
                <option value="low">Baja</option>
                <option value="medium">Media</option>
                <option value="high">Alta</option>
            </select>
        </div>
    </div>
    <button onclick="generateMap()">Generar Mapa</button>
    <button onclick="exportMap()">Exportar como PNG</button>
    <button id="resetBtn" onclick="resetMap()">Resetear Mapa</button>
    <canvas id="map-canvas"></canvas>
    <div class="donate">
        <p>¿Te sirvió? <a href="https://buymeacoffee.com/genio043" target="_blank">Cómprame un té :)</a></p>
    </div>
    <footer>
        <p>Volver a <a href="https://danieldelgado.tech/tools/">Genio043 Tools</a></p>
    </footer>

    <script>
        function generateMap() {
            const mapType = document.getElementById("map-type").value;
            const mapSize = document.getElementById("map-size").value;
            const density = document.getElementById("density").value;

            let width, height;
            switch (mapSize) {
                case "small":
                    width = height = 20;
                    break;
                case "medium":
                    width = height = 40;
                    break;
                case "large":
                    width = height = 60;
                    break;
            }

            const canvas = document.getElementById("map-canvas");
            canvas.width = width * 10; // Escalar para mejor visibilidad
            canvas.height = height * 10;
            const ctx = canvas.getContext("2d");

            // Limpiar el canvas
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Generar mapa según el tipo
            let map;
            switch (mapType) {
                case "dungeon":
                    map = generateDungeon(width, height, density);
                    break;
                case "landscape":
                    map = generateLandscape(width, height, density);
                    break;
                case "city":
                    map = generateCity(width, height, density);
                    break;
            }

            // Dibujar el mapa
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (mapType === "dungeon") {
                        ctx.fillStyle = map[y][x] === 1 ? "#555" : "#ddd"; // Paredes grises, suelo claro
                    } else if (mapType === "landscape") {
                        ctx.fillStyle = map[y][x] === 1 ? "#228B22" : "#F5F5DC"; // Bosque verde, suelo beige
                    } else if (mapType === "city") {
                        ctx.fillStyle = map[y][x] === 1 ? "#8B4513" : "#D3D3D3"; // Edificios marrón, calles grises
                        if (map[y][x] === 2) ctx.fillStyle = "#32CD32"; // Plazas/parques verdes
                    }
                    ctx.fillRect(x * 10, y * 10, 10, 10);
                }
            }
        }

        // Generador de mazmorras (laberinto estructurado con densidad corregida)
        function generateDungeon(width, height, density) {
            const map = Array(height).fill().map(() => Array(width).fill(1)); // Todo paredes inicialmente
            const startX = Math.floor(Math.random() * (width - 2)) + 1;
            const startY = Math.floor(Math.random() * (height - 2)) + 1;
            map[startY][startX] = 0; // Punto de inicio

            const stack = [[startX, startY]];
            const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]]; // Direcciones para pasillos

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const shuffledDirections = directions.sort(() => Math.random() - 0.5);

                for (const [dx, dy] of shuffledDirections) {
                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && map[ny][nx] === 1) {
                        map[ny][nx] = 0; // Nuevo pasillo
                        map[y + dy / 2][x + dx / 2] = 0; // Conectar pasillo
                        stack.push([nx, ny]);
                    }
                }
            }

            // Ajustar según densidad (intercambiando alta y baja)
            let roomCount, roomMinSize, roomMaxSize, extraConnections;
            switch (density) {
                case "low": // Ahora alta densidad: más habitaciones y conexiones
                    roomCount = Math.floor((width * height) / 50); // Más habitaciones
                    roomMinSize = 4;
                    roomMaxSize = 8;
                    extraConnections = 0.5; // Muchas conexiones extra
                    break;
                case "medium":
                    roomCount = Math.floor((width * height) / 100); // Habitaciones moderadas
                    roomMinSize = 3;
                    roomMaxSize = 6;
                    extraConnections = 0.3; // Conexiones moderadas
                    break;
                case "high": // Ahora baja densidad: menos habitaciones y conexiones
                    roomCount = Math.floor((width * height) / 200); // Menos habitaciones
                    roomMinSize = 3;
                    roomMaxSize = 5;
                    extraConnections = 0.1; // Pocas conexiones extra
                    break;
            }

            // Agregar habitaciones (cárceles, plataformas de tortura)
            for (let i = 0; i < roomCount; i++) {
                const roomWidth = Math.floor(Math.random() * (roomMaxSize - roomMinSize + 1)) + roomMinSize;
                const roomHeight = Math.floor(Math.random() * (roomMaxSize - roomMinSize + 1)) + roomMinSize;
                const roomX = Math.floor(Math.random() * (width - roomWidth - 2)) + 1;
                const roomY = Math.floor(Math.random() * (height - roomHeight - 2)) + 1;

                for (let y = roomY; y < roomY + roomHeight; y++) {
                    for (let x = roomX; x < roomX + roomWidth; x++) {
                        map[y][x] = 0; // Crear habitación
                    }
                }
            }

            // Agregar conexiones extra según densidad
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    if (map[y][x] === 1 && Math.random() < extraConnections) {
                        const neighbors = [[0, 1], [1, 0], [0, -1], [-1, 0]];
                        for (const [dx, dy] of neighbors) {
                            if (map[y + dy][x + dx] === 0) {
                                map[y][x] = 0; // Conectar con pasillo
                                break;
                            }
                        }
                    }
                }
            }

            return map;
        }

        // Generador de paisajes (cellular automata, sin cambios)
        function generateLandscape(width, height, density) {
            const map = [];
            let fillPercent;

            switch (density) {
                case "low":
                    fillPercent = 0.3;
                    break;
                case "medium":
                    fillPercent = 0.45;
                    break;
                case "high":
                    fillPercent = 0.6;
                    break;
            }

            for (let y = 0; y < height; y++) {
                map[y] = [];
                for (let x = 0; x < width; x++) {
                    map[y][x] = Math.random() < fillPercent ? 1 : 0;
                }
            }

            for (let i = 0; i < 5; i++) {
                const newMap = [];
                for (let y = 0; y < height; y++) {
                    newMap[y] = [];
                    for (let x = 0; x < width; x++) {
                        const wallCount = countWalls(map, x, y, width, height);
                        newMap[y][x] = wallCount > 4 ? 1 : 0;
                    }
                }
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        map[y][x] = newMap[y][x];
                    }
                }
            }

            return map;
        }

        // Generador de ciudades (cuadrícula con menos uniones y plazas ajustadas)
       function generateCity(width, height, density) {
            const map = Array(height).fill().map(() => Array(width).fill(0)); // Todo calles inicialmente
            let streetSpacing, buildingChance;
        
            // Ajustar espaciado de calles y probabilidad de edificios según densidad
            switch (density) {
                case "low":
                    streetSpacing = 6; // Calles más separadas
                    buildingChance = 0.2; // 20% de probabilidad de edificio por celda
                    break;
                case "medium":
                    streetSpacing = 5; // Calles intermedias
                    buildingChance = 0.4; // 40% de probabilidad de edificio por celda
                    break;
                case "high":
                    streetSpacing = 4; // Calles más juntas
                    buildingChance = 0.6; // 60% de probabilidad de edificio por celda
                    break;
            }
        
            // Crear calles horizontales y verticales
            for (let y = 0; y < height; y += streetSpacing) {
                for (let x = 0; x < width; x++) {
                    map[y][x] = 0; // Calles horizontales
                }
            }
            for (let x = 0; x < width; x += streetSpacing) {
                for (let y = 0; y < height; y++) {
                    map[y][x] = 0; // Calles verticales
                }
            }
        
            // Colocar bloques de edificios entre las calles
            for (let y = 0; y < height - 1; y += streetSpacing) {
                for (let x = 0; x < width - 1; x += streetSpacing) {
                    const blockWidth = Math.min(streetSpacing - 1, Math.floor(Math.random() * 3) + 1); // Ancho 1-3
                    const blockHeight = Math.min(streetSpacing - 1, Math.floor(Math.random() * 3) + 1); // Alto 1-3
                    const startX = x + 1; // Dejar espacio para calle
                    const startY = y + 1;
        
                    // Colocar edificio solo si hay espacio y con probabilidad
                    if (startX + blockWidth < width && startY + blockHeight < height) {
                        if (Math.random() < buildingChance) {
                            for (let by = startY; by < startY + blockHeight; by++) {
                                for (let bx = startX; bx < startX + blockWidth; bx++) {
                                    map[by][bx] = 1; // Edificio
                                }
                            }
                        }
                    }
                }
            }
        
            // Agregar plazas/parques (rectangulares, dentro de la cuadrícula)
            let parkCount;
            if (width === 20 && height === 20) { // Mapa pequeño
                parkCount = 1;
            } else if (width === 40 && height === 40) { // Mapa mediano
                parkCount = Math.floor(Math.random() * 2) + 2; // 2-3 plazas
            } else { // Mapa grande (60x60)
                parkCount = Math.floor(Math.random() * 4) + 2; // 2-5 plazas
            }
        
            for (let i = 0; i < parkCount; i++) {
                const parkWidth = Math.min(streetSpacing - 1, Math.floor(Math.random() * 2) + 2); // Ancho 2-3
                const parkHeight = Math.min(streetSpacing - 1, Math.floor(Math.random() * 2) + 2); // Alto 2-3
                const parkX = Math.floor(Math.random() * (width - parkWidth - 1) / streetSpacing) * streetSpacing + 1;
                const parkY = Math.floor(Math.random() * (height - parkHeight - 1) / streetSpacing) * streetSpacing + 1;
        
                for (let py = parkY; py < Math.min(parkY + parkHeight, height); py++) {
                    for (let px = parkX; px < Math.min(parkX + parkWidth, width); px++) {
                        if (map[py][px] !== 0) { // No sobrescribir calles
                            map[py][px] = 2; // Plaza/parque
                        }
                    }
                }
            }
        
            return map;
        }

        function countWalls(map, x, y, width, height) {
            let count = 0;
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        count += map[ny][nx];
                    } else {
                        count++; // Considerar bordes como paredes
                    }
                }
            }
            return count;
        }

        function exportMap() {
            const canvas = document.getElementById("map-canvas");
            const link = document.createElement("a");
            link.download = "map.png";
            link.href = canvas.toDataURL("image/png");
            link.click();
        }

        function resetMap() {
            const canvas = document.getElementById("map-canvas");
            const ctx = canvas.getContext("2d");
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            document.getElementById("map-type").value = "dungeon";
            document.getElementById("map-size").value = "small";
            document.getElementById("density").value = "medium";
        }
    </script>
</body>
</html>
